// AUTO-GENERATED FILE.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;
import ballerina/protobuf.types.'any as pbAny;
import ballerina/io;


listener http:Listener ep0 = new (8080, config = {host: "localhost"});

CrudServiceClient ep = check new ("http://localhost:50051");

service / on ep0 {
    # Delete an entity
    #
    # + return - Entity deleted 
    resource function delete entities/[string id]() returns http:NoContent|error {
        var result = ep->DeleteEntity({id: id});
        if result is error {
            return result;
        }
        return http:NO_CONTENT;
    }

    # Create a new entity
    #
    # + return - Entity created 
    resource function post entities(@http:Payload json jsonPayload) returns Entity|error {
        // Convert JSON to Entity with custom mapping
        Entity payload = check convertJsonToEntity(jsonPayload);
        
        io:println(payload);
        var result = ep->CreateEntity(payload);
        if result is error {
            return result;
        }
        return result;
    }

    # Update an existing entity
    #
    # + return - Entity updated 
    resource function put entities/[string id](@http:Payload json jsonPayload) returns Entity|error {
        // Convert JSON to Entity with custom mapping
        Entity payload = check convertJsonToEntity(jsonPayload);

        // Create UpdateEntityRequest with both id from URL and entity from payload
        UpdateEntityRequest updateRequest = {
            id: id,
            entity: payload
        };
        
        var result = ep->UpdateEntity(updateRequest);
        if result is error {
            return result;
        }
        return result;
    }

    # Read an entity by ID
    #
    # + id - The ID of the entity to retrieve
    # + return - The entity or an error
    resource function get entities/[string id]() returns Entity|error {
        // Call the ReadEntity function with the ID
        EntityId readEntityRequest = {id: id};
        Entity|error result = ep->ReadEntity(readEntityRequest);
        
        if result is error {
            return result;
        }
        
        // Successfully retrieved the entity
        io:println("Retrieved entity with ID: ", id);
        return result;
    }
}

// Helper function to convert JSON to Entity
function convertJsonToEntity(json jsonPayload) returns Entity|error {
    // Check if metadata is an array or an object
    record {| string key; pbAny:Any value; |}[] metadataArray = [];

    if jsonPayload?.metadata is json[] {
        json[] metadataJsonArray = <json[]>check jsonPayload.metadata;
        foreach json item in metadataJsonArray {
            string key = (check item.key).toString();
            pbAny:Any packedValue = check pbAny:pack((check item.value).toString());
            metadataArray.push({key: key, value: packedValue});
        }
    } else {
        map<json> metadataMap = <map<json>>check jsonPayload.metadata;
        foreach var [key, val] in metadataMap.entries() {
            pbAny:Any packedValue = check pbAny:pack(val.toString());
            metadataArray.push({key: key, value: packedValue});
        }
    }
    
    // Create the entity with proper type reference
    Entity entity = {
        id: (check jsonPayload.id).toString(),
        kind: {
            major: (check jsonPayload.kind.major).toString(),
            minor: (check jsonPayload.kind.minor).toString()
        },
        created: (check jsonPayload.created).toString(),
        terminated: jsonPayload?.terminated is () ? "" : (check jsonPayload.terminated).toString(),
        name: {
            startTime: (check jsonPayload.name.startTime).toString(),
            endTime: jsonPayload?.name?.endTime is () ? "" : (check jsonPayload.name.endTime).toString(),
            value: check pbAny:pack((check jsonPayload.name.value).toString())
        },
        metadata: metadataArray,
        attributes: [],
        relationships: []
    };
    
    return entity;
}
