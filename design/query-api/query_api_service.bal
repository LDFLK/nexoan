// AUTO-GENERATED FILE.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;
import ballerina/protobuf.types.'any;

listener http:Listener ep0 = new (8081, config = {host: "localhost"});

CrudServiceClient ep = check new ("http://localhost:50051");

// Helper function to extract string representation based on typeUrl
function extractValueAsString('any:Any anyValue) returns string {
    string typeUrl = anyValue.typeUrl;
    
    // Default to using the value's string representation
    string valueStr = anyValue.toString();
    
    // Check if it's a known primitive type and handle accordingly
    if (typeUrl.endsWith("string")) {
        return anyValue.value.toString();
    } else if (typeUrl.endsWith("int32") || typeUrl.endsWith("int64") || 
             typeUrl.endsWith("float") || typeUrl.endsWith("double")) {
        return anyValue.value.toString();
    } else if (typeUrl.endsWith("bool")) {
        return anyValue.value.toString();
    } else {
        // For complex types, attempt to return as JSON string if possible
        return valueStr;
    }
}

service /v1 on ep0 {
    # Get entity attribute
    #
    # + return - Attribute value(s) 
    resource function get entities/[string entityId]/attributes/[string attributeName](string? startTime, string? endTime) returns inline_response_200_1|http:NotFound|error {
        // Create entity filter with specific attribute and time range
        Entity entityFilter = {
            id: entityId,
            kind: {
                major: "",
                minor: ""
            },
            created: "",
            terminated: "",
            name: {
                startTime: "",
                endTime: "",
                value: {
                    typeUrl: "type.googleapis.com/google.protobuf.StringValue",
                    value: ""
                }
            },
            metadata: [],
            attributes: [
                {
                    key: attributeName,
                    value: {
                        values: [
                            {
                                startTime: startTime ?: "",
                                endTime: endTime ?: "",
                                value: {
                                    typeUrl: "type.googleapis.com/google.protobuf.StringValue",
                                    value: ""
                                }
                            }
                        ]
                    }
                }
            ],
            relationships: []
        };
        
        // Read the entity using the crud service with attribute filter
        Entity entity = check ep->ReadEntity(entityFilter);
        
        // Process the filtered entity
        foreach var attrEntry in entity.attributes {
            if attrEntry.key == attributeName {
                TimeBasedValueList tbvList = attrEntry.value;
                
                // If we have time parameters, filter the results
                if tbvList.values.length() == 0 {
                    // Return empty array instead of null
                    return []; 
                } else if (tbvList.values.length() == 1) {
                    // Return single value
                    TimeBasedValue tbv = tbvList.values[0];
                    record {string 'start; string? end; string value;} response = {
                        'start: tbv.startTime,
                        end: tbv.endTime,
                        value: extractValueAsString(tbv.value)
                    };
                    return response;
                } else {
                    // Return multiple values
                    record {string 'start; string? end; string value;}[] response = [];
                    foreach var tbv in tbvList.values {
                        response.push({
                            'start: tbv.startTime,
                            end: tbv.endTime,
                            value: extractValueAsString(tbv.value)
                        });
                    }
                    return response;
                }
            }
        }
        
        // Return 404 with a message instead of null
        return <http:NotFound> {
            body: {
                "error": "Attribute not found",
                "attribute": attributeName,
                "entityId": entityId
            }
        };
    }

    # Get metadata of an entity
    #
    # + return - Entity metadata 
    resource function get entities/[string entityId]/metadata() returns EntitiesEntityIdMetadataResponse|error {
        // Create entity filter
        Entity entityFilter = {
            id: entityId,
            kind: {
                major: "",
                minor: ""
            },
            created: "",
            terminated: "",
            name: {
                startTime: "",
                endTime: "",
                value: {
                    typeUrl: "",
                    value: ""
                }
            },
            metadata: [],  // Empty metadata array to indicate we want metadata
            attributes: [],
            relationships: []
        };
        
        // Read the entity using the crud service
        Entity entity = check ep->ReadEntity(entityFilter);
        
        // Convert metadata to generic JSON object
        map<json> metadataJson = {};
        
        // Add all metadata fields
        foreach var entry in entity.metadata {
            metadataJson[entry.key] = extractValueAsString(entry.value);
        }
        
        return metadataJson;
    }

    # Get root entity IDs of a given kind
    #
    # + return - List of root entity IDs 
    resource function get entities/root(string kind) returns inline_response_200 {
        // TODO: implement this once the root entity IDs are identified
        return {};
    }

    # Get all related entity IDs
    #
    # + return - List of all related entities 
    resource function post entities/[string entityId]/allrelations() returns InlineResponse2002ArrayOk|error {
        // Create entity filter without any relationship filtering criteria
        Entity entityFilter = {
            id: entityId,
            kind: {
                major: "",
                minor: ""
            },
            created: "",
            terminated: "",
            name: {
                startTime: "",
                endTime: "",
                value: {
                    typeUrl: "type.googleapis.com/google.protobuf.StringValue",
                    value: ""
                }
            },
            metadata: [],
            attributes: [],
            relationships: []  // No filtering criteria for relationships
        };

        // Read the entity using the crud service
        Entity entity = check ep->ReadEntity(entityFilter);

        // Process the relationships returned by the backend
        inline_response_200_2[] relationships = [];

        foreach var relEntry in entity.relationships {
            Relationship rel = relEntry.value;

            // Add to our result list
            relationships.push({
                relatedEntityId: rel.relatedEntityId,
                startTime: rel.startTime,
                endTime: rel.endTime,
                id: rel.id,
                name: rel.name
            });
        }

        return {body: relationships};
    }

    # Get related entity IDs
    #
    # + return - List of related entities 
    resource function post entities/[string entityId]/relations(@http:Payload entityId_relations_body payload) returns InlineResponse2002ArrayOk|error {
        // Create entity filter with embedded relationship criteria
        Entity entityFilter = {
            id: entityId,
            kind: {
                major: "",
                minor: ""
            },
            created: "",
            terminated: "",
            name: {
                startTime: "",
                endTime: "",
                value: {
                    typeUrl: "type.googleapis.com/google.protobuf.StringValue",
                    value: ""
                }
            },
            metadata: [],
            attributes: [],
            relationships: [
                {
                    key: payload.id,  // Using id as the key
                    value: {
                        relatedEntityId: payload.relatedEntityId,
                        startTime: payload.startTime,
                        endTime: payload.endTime,
                        id: payload.id,
                        name: payload.name
                    }
                }
            ]
        };
        
        // Read the entity using the crud service with relationship filtering
        Entity entity = check ep->ReadEntity(entityFilter);
        
        // Process the relationships returned by the backend
        inline_response_200_2[] relationships = [];
        
        foreach var relEntry in entity.relationships {
            Relationship rel = relEntry.value;
            
            // Add to our result list
            relationships.push({
                relatedEntityId: rel.relatedEntityId,
                startTime: rel.startTime,
                endTime: rel.endTime,
                id: rel.id,
                name: rel.name
            });
        }
        
        return {body: relationships};
    }

    # Find entities based on criteria
    #
    # + return - List of matching entity IDs 
    resource function post entities/search(@http:Payload entities_search_body payload) returns InlineResponse200Ok|error {
        // Create entity filter with search criteria from payload
        return {body: {body: []}};
    }
}
